module test_return_address_stack;
	localparam XLEN = 32;
	localparam STACK_SIZE = 16;

	// generic synchronous signals
	logic clk;
	logic reset;

	// control inputs to ras_control
	logic jump;
	logic jalr;

	// data inputs to RAS/control
	logic [4:0]		rs1_index;
	logic [4:0]		rd_index;
	logic [XLEN-1:0]	address_in;

	// control signals to RAS, generated by ras_control
	logic push;
	logic pop;
	logic checkpoint;
	logic restore_checkpoint;

	logic valid_out;
	logic [XLEN-1:0]	address_out;

	// debug outputs for the return_address_stack
	logic [STACK_SIZE-1:0][XLEN-1:0]	stack;
	logic [STACK_SIZE-1:0]			stack_valid;
	logic [$clog2(STACK_SIZE)-1:0]		stack_pointer;
	logic [$clog2(STACK_SIZE)-1:0]		sp_checkpoint;

	return_address_stack #(.XLEN(XLEN), .STACK_SIZE(STACK_SIZE)) ras (
		.clk(clk),
		.reset(reset),

		.address_in(address_in),
		.push(push),
		.pop(pop),

		.checkpoint(checkpoint),
		.restore_checkpoint(restore_checkpoint),

		.address_out(address_out),
		.valid_out(valid_out),

		// debug outputs
		.stack(stack),
		.stack_valid(stack_valid),
		.stack_pointer(stack_pointer),
		.sp_checkpoint(sp_checkpoint)
	);

	ras_control ras_control (
		.jump(jump),
		.jalr(jalr),
		.rs1_index(rs1_index),
		.rd_index(rd_index),
		
		.push(push),
		.pop(pop)
	);

	// disable the active low reset after the first clock cycle
	initial begin
		#10 reset = 1;
	end

	always begin
		#5 clk = ~clk;
	end

	initial begin	// test logic
		# 10	// wait for reset
		
		jump = 0;
		jalr = 0;
		# 10
		assert(valid_out == 0);	// this is the actual interface to the module
		assert(stack_valid == 'h0000);	// but I'll be checking the internal stack signals to verify the stack is always in the expected state
		assert(stack_pointer == 0);

		jump = 1;
		jalr = 0;	// JAL

		address_in = 'hABCD;
		# 10
		// rs1_index and rd_index are still 0, so nothing should happen on the RAS
		assert(valid_out == 0);	// this is the actual interface to the module
		assert(stack_valid == 'h0000);	// but I'll be checking the internal stack signals to verify the stack is always in the expected state
		assert(stack_pointer == 0);

		// now we set rd_index to a conventional return address register
		// this should push onto the RAS
		rd_index = 1;
		# 2	// not waiting the full clock cycle, just want to see the change to the combinational control logic
		assert(push == 1);
		assert(pop == 0);
		# 8	// wait the rest of the clock cycle
		assert(valid_out == 0);	// we didn't pop anything
		assert(stack_valid == 'h0001);	// an entry should be allocated in the stack
		assert(stack_pointer == 1);	// stack pointer should have been incremented

		// now we'll simply pop that off the stack
		jalr = 1;	// only ever pop if it's a JALR instruction
		rd_index = 0;		// as this would be for a RET pseudoinstruction
		rs1_index = 1;
		# 2	// not waiting full cycle, check combinational control logic
		assert(push == 0);
		assert(pop == 1);
		# 8
		assert(valid_out == 1);	// we popped off the stack, so address_out is valid
		assert(address_out == 'hABCD);
		assert(stack_valid == 'h0000);
		assert(stack_pointer == 0);

		// now let's push a few things onto the stack, some point
		// along the way we'll create a checkpoint too

		rd_index = 1;
		rs1_index = 10;	// this is what it might look like if rs1_index got a value from AUIPC or LUI
		address_in = 'hAAA1;
		# 10
		assert(valid_out == 0);
		assert(stack_valid == 'h0001);
		assert(stack[0] == 'hAAA1);
		assert(stack_pointer == 1);

		address_in = 'hAAA2;
		# 10
		assert(stack_valid == 'h0003);
		assert(stack[1] == 'hAAA2);
		assert(stack_pointer == 2);

		// here we'll create our checkpoint
		jump = 0;	// checkpoints are not created on jump instructions
		checkpoint = 1;	// this is a control signal coming from outside the RAS and ras_control indicating speculative execution
		# 10
		assert(sp_checkpoint == 2);
		checkpoint = 0;

		jump = 1;
		jalr = 0;	// switch to a JAL for fun
		address_in = 'hAAA3;
		# 10
		address_in = 'hAAA4;
		# 10

		assert(valid_out == 0);
		assert(stack_valid == 'h000F);	// we have placed 4 elements on the stack
		assert(stack[0] == 'hAAA1);
		assert(stack[1] == 'hAAA2);
		assert(stack[2] == 'hAAA3);
		assert(stack[3] == 'hAAA4);

		// now let's try the conditions for a push and a pop
		jalr = 1;	// pops only ever happen on JALR
		rd_index = 1;		// conventional link register
		rs1_index = 5;	// conventional alternate link register
		address_in = 'hAAA5;
		# 2
		assert(push == 1);
		assert(pop == 1);
		# 8
		assert(valid_out == 1);
		assert(address_out == 'hAAA4);	// the address that was stored at index 3 should be popped
		assert(stack_valid == 'h000F);	// we have placed 4 elements on the stack
		assert(stack[0] == 'hAAA1);
		assert(stack[1] == 'hAAA2);
		assert(stack[2] == 'hAAA3);
		assert(stack[3] == 'hAAA5);	// the new address that was pushed on should now be stored in place of the address that was popped
		assert(stack_pointer == 4);	// stack_pointer should still be 4, the same number of elements are on the stack

		// now we'll rollback to the checkpoint after a misspeculation
		jump = 0;
		restore_checkpoint = 1;
		# 10
		assert(valid_out == 0);
		assert(stack_pointer == 2);

		restore_checkpoint = 0;
		// now be aware that indices 2 and 3 still have their valid
		// bits set and store the addresses.  this is okay, because
		// the valid bits are not part of the actual interface to the
		// module.  restoring the stack pointer means that those
		// values can never be popped, because those entries will only
		// be accessed if they are pushed and thus overwritten.

		// TODO: pop remaining two values off for completeness I guess,
		// and I guess try popping values off the empty stack and
		// verify valid_out is 0.

		$display("All assertions passed.");
		$finish();
	end
endmodule
